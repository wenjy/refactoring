# refactoring

## 代码的坏味道

### Duplicated Code（重复代码）

> 如果你在一个以上的地方看到相同的程序结构，那么肯定：设法将它们合而唯一，程序会变得更好

### Long Method（过长函数）

> 拥有短函数的对象会活得比较好，比较长。小型函数能带来的益处：解释能力、共享能力、选择能力。

> 让小函数容易理解的真正关键在于一个好名字。如果你能给函数起一个好名字，读者就可以通过名字了解函数的作用，根本不需要去看其中写了什么

> 每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名

> 我们甚至可以对短短的一行代码做这件事情，关键不在于函数的长度，而在于函数"做什么"和"如何做"之间的语义距离

> 如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名

### Divergent Change（发散式变化）一个类受多种变化的影响

> 我们总是希望软件容易修改（开闭原则），类的单一职责，将总是一起变化的东西放一起

### Shotgun Surgery（散弹式修改）一种变化引起多个类相应修改

> 与Divergent Change相反，如果每遇到某种变化，你必须在许多不同的类做出许多小修改

### Feature Envy（依恋情结）

> 对象技术的要点在于：这是一种"将数据和对数据的操作行为包装在一起"的技术，有一种经典的气味是：函数对某个类
>的兴趣高过对自己所处类的兴趣，这种孺慕之情最通常的焦点便是数据

> 判断哪个类拥有最多被此函数使用的数据，然后就把这个函数和那些数据放在一起

### Data Clumps（数据泥团）

> 删除众多数据中的一项。这么做，其他数据有没有因而失去意义？如果它们不仔有意义，这就是一个明确的信号：你应该为它们产生一个新对象

> 一旦拥有新对象，你就有机会让程序散发出一种芳香

### Primitive Obsession（基本类型偏执）

> 对象的一个极大的价值在于：它们模糊了基本数据和体积较大类之间的界限，你可以轻松编写出一些与语言基本类型无异的小型类

> 小任务上也可以运用小对象，例如结合数值和币种的money类、由一个起始值和一个结束值组成的range类、电话号码或者邮政编码等特殊字符串

> 就像PHP的一个时间包一样Carbon

### Switch Statements（switch 惊悚现身）

> 面向对象程序一个明显的特征就是少用switch，因为可以用多态来替换它，或者封装成一个函数

### Parallel Inheritance Hierarchies（平行继承体系）

> 每当你为某个类增加一个子类，必须也为另一个类相应增加一个子类

### Lazy Class（冗余类）

> 你所创建的每一个类，都得有人去理解它、维护它，这些工作都是要花钱的，如果一个类的所得不值其身价，它就应该消失。

### Speculative Generality（夸夸其谈未来性）

> 当有人说："噢，我想我们总有一天需要做这件事情"，并因而企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出来了（过度设计）

### Temporary Field（令人迷惑的暂时字段）

> 对象其内某个实例变量仅为某种特定情况而设，这样的代码让人不易理解，因为你通常认为对象在所有的时候都需要它的所有变量。

### Message Chains（过度耦合的消息链）

> 如果你看到用户向一个对象请求领一个对象，然后再向后者请求另一个对象，然后再请求另一个对象...

### Middle Man（中间人）

> 对象的基本特征之一就是封装--对外部世界隐藏其内部细节。封装往往伴随着委托，你也行会看到某个类接口有一半的函数都委托给其他类，这样就是过度运用。

### Inappropriate Intimacy（狎昵关系）

> 有时你会看到两个类过于亲密，花费太多的时间去探究彼此的private成分。
> 继承往往造成过度亲密，因为子类对父类的了解总是超过后者的主观愿望

### Alternative Classes with Different Interfaces（异曲同工的类）

> 如果两函数做着同一件事情，却有着不同的签名。

### Incomplete Library Class（不完美的类库）

> 复用常被视为对象的终极目的，不过我们认为，复用的意义经常被高估，大多数对象只要够用就好

### Data Class（纯粹的数据类）

> 它们拥有一些字段，以及用于访问这些字段的函数，除此之外一无长物，没有承担起一个类的责任

### Refused Bequest（被拒绝的遗赠）

> 子类应该继承父类的函数和数据。但是如果它们不想或者不需要继承，又该怎么办呢？它们得到所有的礼物，却只从中挑选几样来玩。
> 子类复用了父类的行为，却又不愿意支持父类的接口

### Comments（过多的注释）

> 你看到一段代码有着长长的注释，然后发现，这些注释之所以存在乃是因为代码很糟糕。

> 当你感觉要写注释时，请先尝试重构，试着让所有注释变得多余
